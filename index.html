<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Free Stem Separator - Rys Up Audio</title>
    <!-- COI Service Worker to enable SharedArrayBuffer on GitHub Pages -->
    <script src="coi-serviceworker.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
            background: transparent;
            /* Transparent for Shopify embedding */
            min-height: 100vh;
            padding: 20px;
            color: #1a1a1a;
            overflow: hidden;
            /* Prevent double scrollbars */
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
        }

        .card {
            background: #ffffff;
            border-radius: 16px;
            padding: 30px;
            box-shadow: none;
            /* No shadow when embedded */
            border: 1px solid rgba(0, 0, 0, 0.05);
            /* Subtle border instead */
        }

        .logo {
            text-align: center;
            margin-bottom: 8px;
        }

        .logo svg {
            width: 60px;
            height: 60px;
        }

        h1 {
            text-align: center;
            font-size: 28px;
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 8px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            font-size: 15px;
            margin-bottom: 32px;
        }

        .upload-area {
            border: 2px dashed #e0b0c0;
            border-radius: 12px;
            padding: 48px 24px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #fef7f9;
            margin-bottom: 24px;
        }

        .upload-area:hover {
            border-color: #d88aa0;
            background: #fef0f4;
        }

        .upload-area.dragover {
            border-color: #c97a90;
            background: #fde8ee;
            transform: scale(1.01);
        }

        .upload-area.has-file {
            border-color: #9c6b98;
            background: #f3e5f5;
        }

        .upload-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto 16px;
            color: #d88aa0;
        }

        .upload-text {
            font-size: 16px;
            color: #666;
            margin-bottom: 8px;
        }

        .upload-text strong {
            color: #c97a90;
        }

        .upload-hint {
            font-size: 13px;
            color: #999;
        }

        .file-info {
            display: none;
            align-items: center;
            gap: 12px;
            padding: 16px;
            background: #f8f4f9;
            border-radius: 8px;
            margin-bottom: 24px;
        }

        .file-info.visible {
            display: flex;
        }

        .file-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #d88aa0, #9c6b98);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            flex-shrink: 0;
        }

        .file-details {
            flex: 1;
            min-width: 0;
        }

        .file-name {
            font-weight: 600;
            color: #1a1a1a;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .file-size {
            font-size: 13px;
            color: #888;
        }

        .remove-file {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .remove-file:hover {
            background: #fee;
            color: #c44;
        }

        input[type="file"] {
            display: none;
        }

        .btn-primary {
            width: 100%;
            padding: 16px 24px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #d88aa0, #9c6b98);
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(156, 107, 152, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .progress-section {
            display: none;
            margin-top: 24px;
        }

        .progress-section.visible {
            display: block;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .progress-label {
            font-size: 14px;
            font-weight: 500;
            color: #555;
        }

        .progress-percent {
            font-size: 14px;
            font-weight: 600;
            color: #9c6b98;
        }

        .progress-bar {
            height: 8px;
            background: #f0e4f0;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #d88aa0, #9c6b98);
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-fill.indeterminate {
            width: 30%;
            animation: indeterminate 1.5s ease-in-out infinite;
        }

        @keyframes indeterminate {
            0% {
                margin-left: 0;
            }

            50% {
                margin-left: 70%;
            }

            100% {
                margin-left: 0;
            }
        }

        .status-message {
            text-align: center;
            margin-top: 16px;
            font-size: 14px;
            color: #666;
        }

        .status-message.error {
            color: #c44;
        }

        .status-message.success {
            color: #2a9d2a;
        }

        .stems-section {
            display: none;
            margin-top: 24px;
        }

        .stems-section.visible {
            display: block;
        }

        .stems-header {
            font-size: 16px;
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 16px;
            text-align: center;
        }

        .stems-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .stem-card {
            background: #f8f4f9;
            border-radius: 10px;
            padding: 16px;
            text-align: center;
            transition: all 0.2s;
        }

        .stem-card:hover {
            background: #f3e5f5;
        }

        .stem-icon {
            width: 36px;
            height: 36px;
            margin: 0 auto 8px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
        }

        .stem-icon.drums {
            background: #e57373;
        }

        .stem-icon.bass {
            background: #7986cb;
        }

        .stem-icon.vocals {
            background: #81c784;
        }

        .stem-icon.other {
            background: #ffb74d;
        }

        .stem-name {
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .stem-download {
            background: linear-gradient(135deg, #d88aa0, #9c6b98);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
        }

        .stem-download:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(156, 107, 152, 0.3);
        }

        .download-all {
            margin-top: 16px;
            width: 100%;
            padding: 14px 24px;
            border: 2px solid #9c6b98;
            border-radius: 10px;
            background: white;
            color: #9c6b98;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .download-all:hover {
            background: #9c6b98;
            color: white;
        }

        .info-box {
            background: #fff8e1;
            border-radius: 8px;
            padding: 16px;
            margin-top: 24px;
            font-size: 13px;
            color: #8d6e00;
            line-height: 1.5;
        }

        .info-box strong {
            display: block;
            margin-bottom: 4px;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid #eee;
            font-size: 12px;
            color: #999;
        }

        .footer a {
            color: #9c6b98;
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        /* Loading spinner */
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Memory warning modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal {
            background: white;
            border-radius: 16px;
            padding: 32px;
            max-width: 440px;
            width: 100%;
        }

        .modal h2 {
            font-size: 20px;
            margin-bottom: 12px;
        }

        .modal p {
            color: #666;
            line-height: 1.6;
            margin-bottom: 24px;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
        }

        .modal-btn {
            flex: 1;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .modal-btn.secondary {
            background: #f0f0f0;
            border: none;
            color: #666;
        }

        .modal-btn.primary {
            background: linear-gradient(135deg, #d88aa0, #9c6b98);
            border: none;
            color: white;
        }

        /* Security Badge */
        .security-badge {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s ease;
            cursor: help;
        }

        .security-badge.isolated {
            background: #e8f5e9;
            color: #2e7d32;
            border: 1px solid #c8e6c9;
        }

        .security-badge.not-isolated {
            background: #fff3e0;
            color: #ef6c00;
            border: 1px solid #ffe0b2;
            animation: pulse-warn 2s infinite;
        }

        @keyframes pulse-warn {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }

            100% {
                opacity: 1;
            }
        }

        .badge-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .isolated .badge-dot {
            background: #4caf50;
        }

        .not-isolated .badge-dot {
            background: #ff9800;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="card" style="position: relative;">
            <!-- Security Badge -->
            <div id="securityBadge" class="security-badge not-isolated" title="Checking performance status...">
                <div class="badge-dot"></div>
                <span id="badgeText">Status: Checking...</span>
            </div>

            <!-- Removed logo and headers for Shopify embedding -->
            <h1 style="display: none;">Free Stem Separator</h1>
            <p class="subtitle" style="display: none;">Separate any song into vocals, drums, bass & more</p>

            <!-- Upload Area -->
            <div class="upload-area" id="uploadArea">
                <svg class="upload-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                    <polyline points="17 8 12 3 7 8" />
                    <line x1="12" y1="3" x2="12" y2="15" />
                </svg>
                <p class="upload-text"><strong>Click to upload</strong> or drag and drop</p>
                <p class="upload-hint">MP3 or WAV files (max 50MB)</p>
            </div>
            <input type="file" id="fileInput" accept=".mp3,.wav,audio/mpeg,audio/wav">

            <!-- File Info -->
            <div class="file-info" id="fileInfo">
                <div class="file-icon">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M9 18V5l12-2v13" />
                        <circle cx="6" cy="18" r="3" />
                        <circle cx="18" cy="16" r="3" />
                    </svg>
                </div>
                <div class="file-details">
                    <div class="file-name" id="fileName">song.mp3</div>
                    <div class="file-size" id="fileSize">4.2 MB</div>
                </div>
                <button class="remove-file" id="removeFile" title="Remove file">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18" />
                        <line x1="6" y1="6" x2="18" y2="18" />
                    </svg>
                </button>
            </div>

            <!-- Separate Button -->
            <button class="btn-primary" id="separateBtn" disabled>
                <span id="btnText">Separate Stems</span>
            </button>

            <!-- Progress Section -->
            <div class="progress-section" id="progressSection">
                <div class="progress-header">
                    <span class="progress-label" id="progressLabel">Loading model...</span>
                    <span class="progress-percent" id="progressPercent">0%</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p class="status-message" id="statusMessage">Preparing to separate stems...</p>
            </div>

            <!-- Stems Section -->
            <div class="stems-section" id="stemsSection">
                <h3 class="stems-header">Your Stems Are Ready!</h3>
                <div class="stems-grid">
                    <div class="stem-card">
                        <div class="stem-icon drums">ü•Å</div>
                        <div class="stem-name">Drums</div>
                        <button class="stem-download" data-stem="drums">Download</button>
                    </div>
                    <div class="stem-card">
                        <div class="stem-icon bass">üé∏</div>
                        <div class="stem-name">Bass</div>
                        <button class="stem-download" data-stem="bass">Download</button>
                    </div>
                    <div class="stem-card">
                        <div class="stem-icon vocals">üé§</div>
                        <div class="stem-name">Vocals</div>
                        <button class="stem-download" data-stem="vocals">Download</button>
                    </div>
                    <div class="stem-card">
                        <div class="stem-icon other">üéπ</div>
                        <div class="stem-name">Other</div>
                        <button class="stem-download" data-stem="other">Download</button>
                    </div>
                </div>
                <button class="download-all" id="downloadAll">Download All Stems (ZIP)</button>
            </div>

            <!-- Info Box -->
            <div class="info-box">
                <strong>100% Private & Free</strong>
                All processing happens in your browser. Your audio never leaves your device.
                Processing time varies (5-30 min) depending on your device's power.
            </div>

            <!-- Footer removed for embedding -->
        </div>
    </div>

    <!-- Memory Warning Modal -->
    <div class="modal-overlay" id="memoryModal">
        <div class="modal">
            <h2>Before You Start</h2>
            <p>
                Stem separation uses AI and requires significant memory. For best results:
                <br><br>
                ‚Ä¢ Close other browser tabs<br>
                ‚Ä¢ Use Chrome or Edge (recommended)<br>
                ‚Ä¢ Songs over 5 minutes may take 20+ minutes
            </p>
            <div class="modal-buttons">
                <button class="modal-btn secondary" id="cancelProcess">Cancel</button>
                <button class="modal-btn primary" id="confirmProcess">Continue</button>
            </div>
        </div>
    </div>

    <!-- JSZip for downloading all stems -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <script>
        window.onerror = function (msg, url, lineNo, columnNo, error) {
            alert("Script Error: " + msg + "\nLine: " + lineNo + "\nFile: " + url);
            return false;
        };
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Update Security Badge
            const securityBadge = document.getElementById('securityBadge');
            const badgeText = document.getElementById('badgeText');

            function updateSecurityUI() {
                console.log('=== SIMD Diagnostics ===');
                console.log('crossOriginIsolated:', window.crossOriginIsolated);
                console.log('isSecureContext:', window.isSecureContext);
                const hasSAB = typeof SharedArrayBuffer !== 'undefined';
                console.log('SharedArrayBuffer available:', hasSAB);

                if (window.crossOriginIsolated && hasSAB) {
                    // Modern browsers with COI + SAB support WASM SIMD
                    securityBadge.className = 'security-badge isolated';
                    badgeText.textContent = 'High Performance Mode (SIMD)';
                    securityBadge.title = 'Cross-origin isolated with SharedArrayBuffer. SIMD enabled.';
                    console.log('‚úÖ SIMD Mode Active');
                } else if (window.crossOriginIsolated) {
                    securityBadge.className = 'security-badge not-isolated';
                    badgeText.textContent = 'Standard Mode (No SharedArrayBuffer)';
                    securityBadge.title = 'Cross-origin isolated but SharedArrayBuffer unavailable.';
                    console.log('‚ö†Ô∏è COI but no SAB');
                } else {
                    console.log('NOT cross-origin isolated - checking service worker...');
                    navigator.serviceWorker.getRegistrations().then(regs => {
                        console.log('Service Worker registrations:', regs.length);
                        regs.forEach((reg, i) => console.log('  SW', i, ':', reg.scope, reg.active ? 'ACTIVE' : 'inactive'));
                    });
                    securityBadge.className = 'security-badge not-isolated';
                    badgeText.textContent = 'Standard Mode (COI Failed)';
                    securityBadge.title = 'Cross-origin isolation failed. Check console for details.';
                }
                console.log('========================');
            }
            updateSecurityUI();


            // ============================================
            // CONFIGURATION
            // ============================================
            const CONFIG = {
                wasmJsUrl: 'https://rysupaudio-lab.github.io/stem-separator-assets/demucs_onnx_simd.js',
                wasmUrl: 'https://rysupaudio-lab.github.io/stem-separator-assets/demucs_onnx_simd.wasm',
                modelUrl: 'https://rysupaudio-lab.github.io/stem-separator-assets/ggml-model-htdemucs-4s-f16.bin',
                maxFileSize: 50 * 1024 * 1024
            };

            // ============================================
            // STATE
            // ============================================
            let selectedFile = null;
            let audioContext = null;
            let worker = null;
            let stems = {};

            // ============================================
            // DOM ELEMENTS
            // ============================================
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            const fileInfo = document.getElementById('fileInfo');
            const fileName = document.getElementById('fileName');
            const fileSize = document.getElementById('fileSize');
            const removeFile = document.getElementById('removeFile');
            const separateBtn = document.getElementById('separateBtn');
            const btnText = document.getElementById('btnText');
            const progressSection = document.getElementById('progressSection');
            const progressLabel = document.getElementById('progressLabel');
            const progressPercent = document.getElementById('progressPercent');
            const progressFill = document.getElementById('progressFill');
            const statusMessage = document.getElementById('statusMessage');
            const stemsSection = document.getElementById('stemsSection');
            const memoryModal = document.getElementById('memoryModal');
            const cancelProcess = document.getElementById('cancelProcess');
            const confirmProcess = document.getElementById('confirmProcess');
            const downloadAll = document.getElementById('downloadAll');

            if (!separateBtn || !confirmProcess || !memoryModal) {
                alert("Critical Error: UI elements not found!\n" +
                    (separateBtn ? "" : "btn-missing ") +
                    (confirmProcess ? "" : "confirm-missing ") +
                    (memoryModal ? "" : "modal-missing"));
                return;
            }

            // ============================================
            // FILE HANDLING
            // ============================================
            uploadArea.addEventListener('click', () => fileInput.click());

            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });

            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFile(e.target.files[0]);
                }
            });

            removeFile.addEventListener('click', () => {
                clearFile();
            });

            function handleFile(file) {
                const validTypes = ['audio/mpeg', 'audio/wav', 'audio/mp3', 'audio/wave'];
                const validExtensions = ['.mp3', '.wav'];
                const ext = file.name.toLowerCase().slice(file.name.lastIndexOf('.'));

                if (!validTypes.includes(file.type) && !validExtensions.includes(ext)) {
                    alert('Please upload an MP3 or WAV file.');
                    return;
                }

                if (file.size > CONFIG.maxFileSize) {
                    alert('File is too large. Maximum size is 50MB.');
                    return;
                }

                selectedFile = file;
                fileName.textContent = file.name;
                fileSize.textContent = formatFileSize(file.size);

                uploadArea.style.display = 'none';
                fileInfo.classList.add('visible');
                separateBtn.disabled = false;

                stemsSection.classList.remove('visible');
                stems = {};
            }

            function clearFile() {
                selectedFile = null;
                fileInput.value = '';
                uploadArea.style.display = 'block';
                fileInfo.classList.remove('visible');
                separateBtn.disabled = true;
                stemsSection.classList.remove('visible');
                stems = {};
            }

            function formatFileSize(bytes) {
                if (bytes < 1024) return bytes + ' B';
                if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
            }

            // ============================================
            // SEPARATION PROCESS
            // ============================================
            separateBtn.addEventListener('click', () => {
                console.log('UI: "Separate Stems" clicked - opening modal');
                memoryModal.classList.add('visible');
            });

            cancelProcess.addEventListener('click', () => {
                memoryModal.classList.remove('visible');
            });

            confirmProcess.addEventListener('click', async () => {
                console.log('UI: "Continue" clicked in modal');
                console.log('UI: Starting separation process...');
                memoryModal.classList.remove('visible');

                updateStatus('Checking device compatibility...', 'processing');
                progressSection.classList.add('visible');

                const hasSimd = await checkSimdSupport();
                console.log('UI Diagnostics for Device:', navigator.userAgent);
                console.log('- SIMD check result:', hasSimd);

                if (!hasSimd) {
                    console.warn('SIMD check failing - likely non-SIMD environment');
                    updateStatus('Warning: SIMD not supported. Process will be significantly slower.', 'processing');
                }

                if (!window.crossOriginIsolated) {
                    const confirmReload = confirm("Security Warning:\n\nHigh Performance Mode (SIMD) is not active. This usually requires one refresh after the Service Worker installs.\n\nWithout SIMD, the engine may crash on large files or be 10x slower. Would you like to refresh now?");
                    if (confirmReload) {
                        window.location.reload();
                        return;
                    }
                    updateStatus('Continuing in Standard Mode (Unstable/Slow)...', 'processing');
                }

                startSeparation();
            });

            async function checkSimdSupport() {
                try {
                    if (typeof WebAssembly !== 'object' || typeof WebAssembly.validate !== 'function') {
                        console.error('SIMD Check Error: WebAssembly.validate not found.');
                        return false;
                    }
                    // Robust SIMD Bytecode Checklist:
                    // 1. Minimum 128-bit SIMD validation
                    const wasmByteCode = new Uint8Array([
                        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 26, 11
                    ]);
                    const isValid = WebAssembly.validate(wasmByteCode);
                    console.log('SIMD: Bytecode Validation Result:', isValid);
                    return isValid;
                } catch (e) {
                    console.error('SIMD: Check Exception:', e);
                    return false;
                }
            }

            async function startSeparation() {
                if (!selectedFile) return;

                separateBtn.disabled = true;
                btnText.innerHTML = '<div class="spinner"></div> Processing...';
                progressSection.classList.add('visible');
                progressFill.classList.add('indeterminate');
                progressPercent.textContent = '';
                updateStatus('Loading audio file...', 'processing');

                try {
                    updateStatus('Decoding audio...', 'processing');
                    const audioData = await decodeAudioFile(selectedFile);

                    if (audioData.duration > 600) {
                        throw new Error('Song is too long. Please use a file under 10 minutes.');
                    }

                    const estMem = Math.round((audioData.duration * 44100 * 40) / 1024 / 1024) + 200;
                    console.log('Estimated peak memory: ' + estMem + ' MB');

                    if (!worker) {
                        updateStatus('Initializing AI engine...', 'processing');
                        await restoreWorker();
                    }

                    updateStatus('Separating stems (RAM: ~' + estMem + 'MB)...', 'processing');
                    progressFill.classList.remove('indeterminate');

                    const result = await separateStems(audioData);
                    stems = result;

                    updateStatus('Separation complete!', 'success');
                    progressFill.style.width = '100%';
                    progressPercent.textContent = '100%';

                    setTimeout(() => {
                        progressSection.classList.remove('visible');
                        stemsSection.classList.add('visible');
                        separateBtn.disabled = false;
                        btnText.textContent = 'Separate Another';
                    }, 1000);

                } catch (error) {
                    console.error('Separation failure diagnostics:', error);
                    let rawMsg = error.message || 'Unknown error';
                    let debugLog = error.debugLog || '';
                    let msg = rawMsg;

                    if (rawMsg.includes('exit(1)') || rawMsg.includes('Program terminated') || rawMsg.includes('Aborted')) {
                        msg = 'The engine crashed. This usually means your device ran out of RAM or truly doesn\'t support SIMD. (Original: ' + rawMsg + ')';
                    }

                    if (debugLog) {
                        msg += '\\n\\nEngine Log Detail:\\n' + debugLog;
                    }

                    updateStatus('Error: ' + msg, 'error');
                    separateBtn.disabled = false;
                    btnText.textContent = 'Try Again';
                    progressFill.classList.remove('indeterminate');
                    if (worker) {
                        worker.terminate();
                        worker = null;
                    }
                }
            }

            function updateStatus(message, state) {
                statusMessage.textContent = message;
                statusMessage.className = 'status-message ' + state;
                progressLabel.textContent = state === 'processing' ? 'Processing...' :
                    state === 'success' ? 'Complete!' : 'Error';
            }

            function updateProgress(percent) {
                progressFill.style.width = percent + '%';
                progressPercent.textContent = Math.round(percent) + '%';
            }

            async function decodeAudioFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    console.log('Decoding: Starting file read...', file.name, file.size);

                    reader.onload = async (e) => {
                        try {
                            if (!audioContext) {
                                console.log('Decoding: Initializing AudioContext...');
                                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                                    sampleRate: 44100
                                });
                            }

                            if (audioContext.state === 'suspended') {
                                console.log('Decoding: Resuming suspended AudioContext...');
                                await audioContext.resume();
                            }

                            console.log('Decoding: Beginning decodeAudioData (Bytes: ' + e.target.result.byteLength + ')');

                            let audioBuffer;
                            try {
                                audioBuffer = await audioContext.decodeAudioData(e.target.result);
                            } catch (decodeErr) {
                                console.error('Decoding: decodeAudioData failed:', decodeErr);
                                throw new Error('Web Audio API failed to decode the file: ' + (decodeErr.message || 'Unknown error. File may be corrupted or too large.'));
                            }

                            console.log('Decoding: Success! Channels:', audioBuffer.numberOfChannels, 'Duration:', audioBuffer.duration);

                            let buffer = audioBuffer;
                            if (audioBuffer.sampleRate !== 44100) {
                                console.log('Decoding: Resampling from ' + audioBuffer.sampleRate + ' to 44100');
                                const offlineCtx = new OfflineAudioContext(2, audioBuffer.duration * 44100, 44100);
                                const source = offlineCtx.createBufferSource();
                                source.buffer = audioBuffer;
                                source.connect(offlineCtx.destination);
                                source.start();
                                buffer = await offlineCtx.startRendering();
                            }

                            const leftChannel = buffer.getChannelData(0);
                            const rightChannel = buffer.numberOfChannels > 1 ?
                                buffer.getChannelData(1) : leftChannel;

                            resolve({
                                left: leftChannel,
                                right: rightChannel,
                                sampleRate: 44100,
                                duration: buffer.duration
                            });
                        } catch (err) {
                            console.error('Decoding: Process failed:', err);
                            reject(err);
                        }
                    };
                    reader.onerror = () => reject(new Error('Failed to read file from disk.'));
                    reader.readAsArrayBuffer(file);
                });
            }

            async function restoreWorker() {
                return new Promise((resolve, reject) => {
                    console.log('UI: Initializing Worker via worker.js...');
                    worker = new Worker('worker.js');

                    worker.onmessage = (e) => {
                        const { type, message, progress, error, stems, sampleRate } = e.data;
                        if (type === 'status') updateStatus(message, 'processing');
                        else if (type === 'initialized') {
                            console.log('UI: Worker initialized successfully.');
                            resolve();
                        }
                        else if (type === 'progress') updateProgress(progress);
                        else if (type === 'error') {
                            const err = new Error(error);
                            err.debugLog = e.data.debugLog;
                            console.error('UI: Worker error received:', error);
                            reject(err);
                        }
                        else if (type === 'complete') {
                            if (worker._resolveComplete) {
                                worker._resolveComplete({ stems, sampleRate });
                            }
                        }
                    };

                    worker.onerror = (err) => {
                        console.error('UI: Worker hard error:', err);
                        reject(new Error('Worker filed to start. Ensure worker.js is in the same folder as index.html.'));
                    };

                    worker.postMessage({
                        type: 'init',
                        data: {
                            wasmJsUrl: new URL(CONFIG.wasmJsUrl, window.location.href).href,
                            wasmUrl: new URL(CONFIG.wasmUrl, window.location.href).href,
                            modelUrl: new URL(CONFIG.modelUrl, window.location.href).href
                        }
                    });
                });
            }

            async function separateStems(audioData) {
                return new Promise((resolve, reject) => {
                    worker._resolveComplete = (res) => {
                        worker._resolveComplete = null;
                        worker._rejectComplete = null;
                        resolve(res);
                    };
                    worker._rejectComplete = (err) => {
                        worker._resolveComplete = null;
                        worker._rejectComplete = null;
                        reject(err);
                    };

                    worker.postMessage({
                        type: 'separate',
                        data: {
                            left: audioData.left,
                            right: audioData.right,
                            sampleRate: audioData.sampleRate
                        }
                    }, [audioData.left.buffer, audioData.right.buffer]);
                });
            }

            // ============================================
            // STEM DOWNLOAD
            // ============================================
            document.querySelectorAll('.stem-download').forEach(btn => {
                btn.addEventListener('click', () => {
                    const stemName = btn.dataset.stem;
                    if (stems[stemName]) {
                        downloadStem(stemName, stems[stemName]);
                    }
                });
            });

            downloadAll.addEventListener('click', async () => {
                if (Object.keys(stems).length === 0) return;

                const zip = new JSZip();
                const baseName = selectedFile ? selectedFile.name.replace(/\.[^/.]+$/, '') : 'track';

                for (const [name, data] of Object.entries(stems)) {
                    const wavBlob = createWavBlob(data.left, data.right, data.sampleRate || 44100);
                    zip.file(`${baseName}_${name}.wav`, wavBlob);
                }

                const zipBlob = await zip.generateAsync({ type: 'blob' });
                downloadBlob(zipBlob, `${baseName}_stems.zip`);
            });

            function downloadStem(name, data) {
                const baseName = selectedFile ? selectedFile.name.replace(/\.[^/.]+$/, '') : 'track';
                const wavBlob = createWavBlob(data.left, data.right, data.sampleRate || 44100);
                downloadBlob(wavBlob, `${baseName}_${name}.wav`);
            }

            function createWavBlob(leftChannel, rightChannel, sampleRate) {
                const numChannels = 2;
                const numSamples = leftChannel.length;
                const bytesPerSample = 2;
                const blockAlign = numChannels * bytesPerSample;
                const byteRate = sampleRate * blockAlign;
                const dataSize = numSamples * blockAlign;
                const bufferSize = 44 + dataSize;

                const buffer = new ArrayBuffer(bufferSize);
                const view = new DataView(buffer);

                writeString(view, 0, 'RIFF');
                view.setUint32(4, bufferSize - 8, true);
                writeString(view, 8, 'WAVE');
                writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, numChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, byteRate, true);
                view.setUint16(32, blockAlign, true);
                view.setUint16(34, bytesPerSample * 8, true);
                writeString(view, 36, 'data');
                view.setUint32(40, dataSize, true);

                let offset = 44;
                for (let i = 0; i < numSamples; i++) {
                    const leftSample = Math.max(-1, Math.min(1, leftChannel[i]));
                    const rightSample = Math.max(-1, Math.min(1, rightChannel[i]));

                    view.setInt16(offset, leftSample * 32767, true);
                    view.setInt16(offset + 2, rightSample * 32767, true);
                    offset += 4;
                }

                return new Blob([buffer], { type: 'audio/wav' });
            }

            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }

            function downloadBlob(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        });
    </script>
</body>

</html>